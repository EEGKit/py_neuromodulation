{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "9d66239e",
   "metadata": {},
   "source": [
    "# ParametrizationDefinition\n",
    "\n",
    "### nm_settings.json\n",
    "\n",
    "In order to estimate multimodal features of neurophysiological data, certain parametrization steps are required. \n",
    "Here the following two parametrization files are explained: \n",
    " - `nm_settings.json`\n",
    " - `nm_channels.csv`\n",
    " \n",
    "The `nm_settings.json` specifies the general feature processing. Most importantly, all provided features can be enabled and disabled: \n",
    "```json\n",
    "\"methods\": \n",
    "{\n",
    "        \"raw_resampling\": false,\n",
    "        \"normalization\": true,\n",
    "        \"kalman_filter\": true,\n",
    "        \"re_referencing\": true,\n",
    "        \"notch_filter\": true,\n",
    "        \"bandpass_filter\": true,\n",
    "        \"raw_hjorth\": true,\n",
    "        \"sharpwave_analysis\": true,\n",
    "        \"return_raw\": true,\n",
    "        \"project_cortex\": false,\n",
    "        \"project_subcortex\": false,\n",
    "        \"pdc\": false,\n",
    "        \"dtf\": false\n",
    "}\n",
    "```\n",
    "\n",
    "**raw_resampling** defines a resampling rate to which the original data is downsampled to. This can be of advantage, since high sampling frequencies automatically require higher computational cost. In the method specific settings the resampling frequency can be defined: \n",
    "\n",
    "```json\n",
    "\"raw_resampling_settings\": {\n",
    "        \"resample_freq\": 1000\n",
    "    }\n",
    "```\n",
    "\n",
    "**normalization** allows for normalizing the past *normalization_time* according to either the *mean* or *median* *normalization_method* in the following manner for *median*:\n",
    "\n",
    "$X_{norm} = \\frac{X - median(X)}{median(X)}$\n",
    "```json\n",
    "\"raw_normalization_settings\": {\n",
    "        \"normalization_time\": 10,\n",
    "        \"normalization_method\": \"median\"\n",
    "    }\n",
    "\n",
    "```\n",
    "\n",
    "**kalman_filtering** is motivated by filtering estimated band power features using the white noise acceleration model (see [\"Improved detection of Parkinsonian resting tremor with feature engineering and Kalman filtering\"](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6927801/) Yao et al 19) for a great reference. The white noise acceleration model get's specified by the $T_p$ prediction interval (Hz), and the process noise is then defined by $\\sigma_w$ and $\\sigma_v$: \n",
    "\n",
    "$\n",
    "  Q=\n",
    "  \\left[ {\\begin{array}{cc}\n",
    "   \\sigma_w^2\\frac{T_p^{3}}{3} & \\sigma_w^2\\frac{T_p^2}{2}\\\\\n",
    "   \\sigma_w^2\\frac{T_p^2}{3} & \\sigma_w^2T_p\\\\\n",
    "  \\end{array} } \\right]\n",
    "$\n",
    "\n",
    "\n",
    "```json\n",
    "\"kalman_filter_settings\": {\n",
    "        \"Tp\": 0.1,\n",
    "        \"sigma_w\": 0.7,\n",
    "        \"sigma_v\": 1,\n",
    "        \"frequency_bands\": [\n",
    "            \"low gamma\",\n",
    "            \"high gamma\",\n",
    "            \"all gamma\"\n",
    "        ]\n",
    "    }\n",
    "```\n",
    "Individual frequency bands (specified in the **bandpass_filter_settings**) can be selected for Kalman Filtering (see [\"Real-time epileptic seizure prediction using AR models and support vector machines\"](https://pubmed.ncbi.nlm.nih.gov/20172805/) (Chisci et al 10)) \n",
    "\n",
    "**re_referencing** constitutes an important aspect of electrophysiological signal processing. Most commonly bipolar and common average rereferencing are applied. Due to that reason a seperate file, `nm_channels.csv` can be specified before feature estimation, or it is automatically setup during parametrization.`nm_channels.csv` contains a column *rereference*, specifying the rereference methods \n",
    " - *average* for common average rereference (across a channel type, e.g. ecog)\n",
    " - bipolar rereferencing, by specifying the channel name to rereference to, e.g. *LFP_BS_STN_L_1*\n",
    " - *none* for no rereferencing being used for this particular channel \n",
    "\n",
    "**notch_filter** enables notch filters at the specified line_noise and it's harmonics. \n",
    "\n",
    "**bandpass_filter** enables band power feature estimation. Settings are defined in such manner: \n",
    "```json\n",
    "\"bandpass_filter_settings\": {\n",
    "    \"frequency_ranges\": {\n",
    "        \"theta\": [\n",
    "            [\n",
    "                4,\n",
    "                8\n",
    "            ],\n",
    "            1000\n",
    "            ]\n",
    "    }, \n",
    "    \"bandpower_features\": {\n",
    "        \"activity\": true,\n",
    "        \"mobility\": true,\n",
    "        \"complexity\": true\n",
    "    }\n",
    "}\n",
    "```\n",
    "\n",
    "Here the name (in this case *theta*) get's specified, and in the the subsequent list the frequency range (here from 4 - 8 Hz) is defined. Then, the last parameter defines a time range in which FIR filtered data is used for feature estimation in milliseconds. Here the previous 1000 ms are used to estimate features based on the FIR filtered signals in the range of 4 to 8 Hz. This might be beneficial when using shorter frequency bands, e.g. gamma, where estimating band power in a range of e.g. 100 ms might result in a temporal more specified feature calculation. \n",
    "A common way to estimate band power is to take the variance of FIR filtered data. This is equavilent to the activity [Hjorth](https://en.wikipedia.org/wiki/Hjorth_parameters) parameter. The last key in the *bandpass_filter_settings* allows to take the *activity*, *mobility* and *complexity* Hjorth parameters as well. For estimating Hjorth parameters of the raw unfiltered signal, the **raw_hjorth** method can be enabled. \n",
    "\n",
    "**sharpwave_analysis** allows for calculation of temporal sharpwave features. See [\"Brain Oscillations and the Importance of Waveform Shape\"](https://www.sciencedirect.com/science/article/abs/pii/S1364661316302182) Cole et al 17 for a great motivation to use these features. Here, sharpwave features are estimated using a prior bandpass filter  between *filter_low_cutoff* and *filter_high_cutoff*. The sharpwave peak and trough features can be calculated, defined by the *estimate* key. According to a current data batch one or more sharpwaves can be detected. The subsequent feature is returned rather by the *mean, median, maximum, minimum or variance* as defined by the *estimator*. \n",
    "```json\n",
    "\"sharpwave_analysis_settings\": {\n",
    "    \"sharpwave_features\": {\n",
    "        \"peak_left\": true,\n",
    "        \"peak_right\": true,\n",
    "        \"trough\": true,\n",
    "        \"width\": true,\n",
    "        \"prominence\": true,\n",
    "        \"interval\": true,\n",
    "        \"decay_time\": true,\n",
    "        \"rise_time\": true,\n",
    "        \"sharpness\": true,\n",
    "        \"rise_steepness\": true,\n",
    "        \"decay_steepness\": true,\n",
    "        \"slope_ratio\": true\n",
    "    },\n",
    "    \"filter_low_cutoff\": 5,\n",
    "    \"filter_high_cutoff\": 90,\n",
    "    \"detect_troughs\": {\n",
    "        \"estimate\": true,\n",
    "        \"distance_troughs\": 5,\n",
    "        \"distance_peaks\": 1\n",
    "    },\n",
    "    \"detect_peaks\": {\n",
    "        \"estimate\": true,\n",
    "        \"distance_troughs\": 1,\n",
    "        \"distance_peaks\": 5\n",
    "    },\n",
    "    \"estimator\": {\n",
    "        \"mean\": true,\n",
    "        \"median\": true,\n",
    "        \"max\": true,\n",
    "        \"min\": true,\n",
    "        \"var\": true\n",
    "    }\n",
    "}\n",
    "```\n",
    "A separate tutorial on sharpwave features is provided in the documentation. \n",
    "\n",
    "Next, raw signals can be returned, specifed by the **return_raw** method. \n",
    "\n",
    "**projection_cortex** and **projection_subcortex** allows then feature projection of individual channels to a common subcortical or cortical grid, defined by *grid_cortex.tsv* and *subgrid_cortex.tsv*. For both projections a *max_dist* parameter needs to be specified, in which data is linearly interpolated, weighted by their inverse grid point distance. \n",
    "\n",
    "Additionally **pdc** and **dtf** enable partical directed coherence and direct transfer function, to enable connectiviy features for certain *frequency_bands* between specific channels. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b05be78f",
   "metadata": {},
   "source": [
    "### nm_channels.csv\n",
    "\n",
    "As described above, rereferencing will be estimated automatically given the specified channel types. To demonstrate a typical rereferencing scheme, here the example BIDS data in 'py_neuromodulation/examples/data' is read.\n",
    "\n",
    "First, the path needs to specified and necessary libaries imported:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "b1b947ea",
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "from bids import BIDSLayout\n",
    "import os\n",
    "import json\n",
    "from pathlib import Path\n",
    "\n",
    "# first specify path to get example folder, second py_neuromodulation folder\n",
    "PATH_PYNEUROMODULATION = Path(\"__file__\").absolute().parent.parent  # \"__file__\" required for ipynb\n",
    "sys.path.append(os.path.join(PATH_PYNEUROMODULATION))\n",
    "\n",
    "from pyneuromodulation import nm_start_BIDS, nm_settings, nm_IO"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "035593bc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Reading nm_settings.json.\n",
      "Testing settings.\n",
      "No Error occurred when testing the settings.\n"
     ]
    }
   ],
   "source": [
    "BIDS_EXAMPLE_PATH = os.path.abspath(os.path.join(PATH_PYNEUROMODULATION,\n",
    "                                    'examples', 'data'))\n",
    "\n",
    "PATH_RUN = os.path.join(BIDS_EXAMPLE_PATH, 'sub-testsub', 'ses-EphysMedOff',\n",
    "                        'ieeg', \"sub-testsub_ses-EphysMedOff_task-buttonpress_run-0_ieeg.vhdr\")\n",
    "\n",
    "\n",
    "settings_wrapper = nm_settings.SettingsWrapper(settings_path=os.path.join(os.pardir, 'pyneuromodulation', 'nm_settings.json'))\n",
    "# read and test settings first to obtain BIDS path\n",
    "settings_wrapper.settings['BIDS_path'] = BIDS_EXAMPLE_PATH"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b0275464",
   "metadata": {},
   "source": [
    "Then the nm_channels.csv file is automatically specifed given the respective channel types. Since one channel contains an 'analog' substring, it is automaticaly assginged to be a *target* channel. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "dea641cc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Extracting parameters from C:\\Users\\ICN_admin\\Documents\\py_neuromodulation\\examples\\data\\sub-testsub\\ses-EphysMedOff\\ieeg\\sub-testsub_ses-EphysMedOff_task-buttonpress_run-0_ieeg.vhdr...\n",
      "Setting channel info structure...\n",
      "Reading channel info from C:\\Users\\ICN_admin\\Documents\\py_neuromodulation\\examples\\data\\sub-testsub\\ses-EphysMedOff\\ieeg\\sub-testsub_ses-EphysMedOff_task-buttonpress_run-0_channels.tsv.\n",
      "Reading in coordinate system frame Other: None.\n",
      "Reading electrode coords from C:\\Users\\ICN_admin\\Documents\\py_neuromodulation\\examples\\data\\sub-testsub\\ses-EphysMedOff\\ieeg\\sub-testsub_ses-EphysMedOff_acq-StimOff_space-mni_electrodes.tsv.\n",
      "The read in electrodes file is: \n",
      " [('name', ['ECOG_AT_SM_L_1', 'ECOG_AT_SM_L_2', 'ECOG_AT_SM_L_3', 'ECOG_AT_SM_L_4', 'ECOG_AT_SM_L_5', 'ECOG_AT_SM_L_6', 'LFP_STN_R_234', 'LFP_STN_R_567', 'LFP_BS_STN_L_1', 'LFP_STN_L_234', 'LFP_STN_L_567', 'LFP_3_R_STN_PI', 'LFP_4_R_STN_PI', 'ANALOG_ROT_R_1']), ('x', ['-47', '-46', '-45.5', '-44.5', '-42', '-39', '11.8', '12.39', '-11.3', '-11.8', '-12.39', '12.93', '13.4', 'n/a']), ('y', ['-26', '-15.5', '-5.5', '4', '14', '22.5', '-15', '-14.29', '-15.9', '-15', '-14.29', '-13.41', '-12.52', 'n/a']), ('z', ['65', '63', '60.5', '57.5', '53.5', '49.5', '-7.7', '-5.9', '-9.9', '-7.7', '-5.9', '-4.1', '-2.2', 'n/a']), ('size', ['n/a', 'n/a', 'n/a', 'n/a', 'n/a', 'n/a', 'n/a', 'n/a', 'n/a', 'n/a', 'n/a', 'n/a', 'n/a', 'n/a'])]\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\ICN_admin\\Anaconda3\\envs\\pyneuromodulation\\lib\\site-packages\\mne_bids\\path.py:1303: RuntimeWarning: Did not find any events.tsv associated with sub-testsub_ses-EphysMedOff_task-buttonpress_run-0.\n",
      "\n",
      "The search_str was \"C:\\Users\\ICN_admin\\Documents\\py_neuromodulation\\examples\\data\\sub-testsub\\**\\sub-testsub_ses-EphysMedOff*events.tsv\"\n",
      "  warn(msg)\n",
      "C:\\Users\\ICN_admin\\Anaconda3\\envs\\pyneuromodulation\\lib\\site-packages\\mne_bids\\dig.py:467: RuntimeWarning: Defaulting coordinate frame to unknown from coordinate system input Other\n",
      "  warn(f\"Defaulting coordinate frame to unknown \"\n",
      "C:\\Users\\ICN_admin\\Anaconda3\\envs\\pyneuromodulation\\lib\\site-packages\\mne_bids\\dig.py:514: RuntimeWarning: There are channels without locations (n/a) that are not marked as bad: ['ANALOG_ROT_R_1']\n",
      "  warn(f\"There are channels without locations \"\n",
      "C:\\Users\\ICN_admin\\Anaconda3\\envs\\pyneuromodulation\\lib\\site-packages\\mne_bids\\dig.py:521: RuntimeWarning: Fiducial point nasion not found, assuming identity unknown to head transformation\n",
      "  raw.set_montage(montage, on_missing='warn', verbose=verbose)\n"
     ]
    }
   ],
   "source": [
    "# read BIDS data\n",
    "raw_arr, raw_arr_data, fs, line_noise = nm_IO.read_BIDS_data(PATH_RUN, settings_wrapper.settings[\"BIDS_path\"])\n",
    "\n",
    "# read df_M1 / create M1 if None specified\n",
    "settings_wrapper.set_nm_channels(nm_channels_path=None, ch_names=raw_arr.ch_names,\n",
    "                        ch_types=raw_arr.get_channel_types())\n",
    "settings_wrapper.set_fs_line_noise(fs, line_noise)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5f0c8cd2",
   "metadata": {},
   "source": [
    "Based on 'seeg' type (could be also 'dbs'), the subsequent depth local field potential channel is selected for rereferencing. For 'ecog' channels, the average rereference function is automatically assigned. \n",
    "\n",
    "Note here also that channels can be 'used' for feature analysis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "3e8dbfff",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>name</th>\n",
       "      <th>rereference</th>\n",
       "      <th>used</th>\n",
       "      <th>target</th>\n",
       "      <th>type</th>\n",
       "      <th>status</th>\n",
       "      <th>new_name</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>LFP_STN_R_234</td>\n",
       "      <td>LFP_STN_R_567</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>seeg</td>\n",
       "      <td>good</td>\n",
       "      <td>LFP_STN_R_234-LFP_STN_R_567</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>LFP_STN_R_567</td>\n",
       "      <td>LFP_STN_R_234</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>seeg</td>\n",
       "      <td>good</td>\n",
       "      <td>LFP_STN_R_567-LFP_STN_R_234</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>LFP_BS_STN_L_1</td>\n",
       "      <td>LFP_STN_L_567</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>seeg</td>\n",
       "      <td>good</td>\n",
       "      <td>LFP_BS_STN_L_1-LFP_STN_L_567</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>LFP_STN_L_234</td>\n",
       "      <td>LFP_BS_STN_L_1</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>seeg</td>\n",
       "      <td>good</td>\n",
       "      <td>LFP_STN_L_234-LFP_BS_STN_L_1</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>LFP_STN_L_567</td>\n",
       "      <td>LFP_STN_L_234</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>seeg</td>\n",
       "      <td>good</td>\n",
       "      <td>LFP_STN_L_567-LFP_STN_L_234</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>ECOG_AT_SM_L_1</td>\n",
       "      <td>average</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>ecog</td>\n",
       "      <td>good</td>\n",
       "      <td>ECOG_AT_SM_L_1-avgref</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>ECOG_AT_SM_L_2</td>\n",
       "      <td>average</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>ecog</td>\n",
       "      <td>good</td>\n",
       "      <td>ECOG_AT_SM_L_2-avgref</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>ECOG_AT_SM_L_3</td>\n",
       "      <td>average</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>ecog</td>\n",
       "      <td>good</td>\n",
       "      <td>ECOG_AT_SM_L_3-avgref</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>ECOG_AT_SM_L_4</td>\n",
       "      <td>average</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>ecog</td>\n",
       "      <td>good</td>\n",
       "      <td>ECOG_AT_SM_L_4-avgref</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>9</th>\n",
       "      <td>ECOG_AT_SM_L_5</td>\n",
       "      <td>average</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>ecog</td>\n",
       "      <td>good</td>\n",
       "      <td>ECOG_AT_SM_L_5-avgref</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10</th>\n",
       "      <td>ECOG_AT_SM_L_6</td>\n",
       "      <td>average</td>\n",
       "      <td>1</td>\n",
       "      <td>0</td>\n",
       "      <td>ecog</td>\n",
       "      <td>good</td>\n",
       "      <td>ECOG_AT_SM_L_6-avgref</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>11</th>\n",
       "      <td>ANALOG_ROT_R_1</td>\n",
       "      <td>None</td>\n",
       "      <td>0</td>\n",
       "      <td>1</td>\n",
       "      <td>misc</td>\n",
       "      <td>good</td>\n",
       "      <td>ANALOG_ROT_R_1</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "              name     rereference  used  target  type status  \\\n",
       "0    LFP_STN_R_234   LFP_STN_R_567     1       0  seeg   good   \n",
       "1    LFP_STN_R_567   LFP_STN_R_234     1       0  seeg   good   \n",
       "2   LFP_BS_STN_L_1   LFP_STN_L_567     1       0  seeg   good   \n",
       "3    LFP_STN_L_234  LFP_BS_STN_L_1     1       0  seeg   good   \n",
       "4    LFP_STN_L_567   LFP_STN_L_234     1       0  seeg   good   \n",
       "5   ECOG_AT_SM_L_1         average     1       0  ecog   good   \n",
       "6   ECOG_AT_SM_L_2         average     1       0  ecog   good   \n",
       "7   ECOG_AT_SM_L_3         average     1       0  ecog   good   \n",
       "8   ECOG_AT_SM_L_4         average     1       0  ecog   good   \n",
       "9   ECOG_AT_SM_L_5         average     1       0  ecog   good   \n",
       "10  ECOG_AT_SM_L_6         average     1       0  ecog   good   \n",
       "11  ANALOG_ROT_R_1            None     0       1  misc   good   \n",
       "\n",
       "                        new_name  \n",
       "0    LFP_STN_R_234-LFP_STN_R_567  \n",
       "1    LFP_STN_R_567-LFP_STN_R_234  \n",
       "2   LFP_BS_STN_L_1-LFP_STN_L_567  \n",
       "3   LFP_STN_L_234-LFP_BS_STN_L_1  \n",
       "4    LFP_STN_L_567-LFP_STN_L_234  \n",
       "5          ECOG_AT_SM_L_1-avgref  \n",
       "6          ECOG_AT_SM_L_2-avgref  \n",
       "7          ECOG_AT_SM_L_3-avgref  \n",
       "8          ECOG_AT_SM_L_4-avgref  \n",
       "9          ECOG_AT_SM_L_5-avgref  \n",
       "10         ECOG_AT_SM_L_6-avgref  \n",
       "11                ANALOG_ROT_R_1  "
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "settings_wrapper.nm_channels"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "pyneuromodulation",
   "language": "python",
   "name": "pyneuromodulation"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
